---
title: "告別『空白頁面恐懼症』：Next.js 如何用多種渲染策略拯救你的 SEO？"
date: 2024-01-03
categories:
  - 前端二三事
  - Next.js 深入
  - 網頁渲染與效能
tags:
  - Next.js
  - SSR
  - SSG
  - CSR
  - Hydration
excerpt: "從客戶端渲染到伺服器端渲染，再到靜態網站生成，Next.js 提供多種策略以應對不同的效能與 SEO 挑戰。本文將深入剖析這些渲染魔法的運作原理。"
---


## Next.js 渲染策略詳解：CSR, SSR, SSG 與 ISR

過去，我們用 React 等函式庫打造的 SPA (單頁式應用程式) 雖然提供了豐富的互動體驗，但這種開發模式也產生了幾個問題。預設的**客戶端渲染 (Client-Side Rendering, CSR)** 模式，常常導致搜尋引擎優化 (SEO) 效果不佳，以及使用者在初次載入時必須面對一段惱人的「白畫面」等待時間。

這些問題，早在 Backbone.js 和 AngularJS 的時代就已經出現。為了解決這些由 CSR 帶來的限制，前端社群發展出了多種預先渲染 (Pre-rendering) 的策略。**Next.js** 這個框架，正是為了解決這些問題而生，它將這些策略內建並標準化，讓開發者可以根據不同需求靈活選用。

本文將從問題的根本——CSR——開始，逐一說明 Next.js 提供的幾種主要渲染模式。

## 1. 問題的起點：客戶端渲染 (CSR)

**客戶端渲染 (CSR)** 的運作方式，是伺服器先回傳一個最小化的 HTML 文件，這個文件本身幾乎沒有內容，只包含一個掛載點 (例如 `<div id="root"></div>`) 和一個 `<script>` 標籤，用來引入主要的 JavaScript 檔案包。

它的流程是這樣的：
1.  瀏覽器向伺服器請求頁面。
2.  伺服器回傳一個近乎空白的 HTML 檔案。
3.  瀏覽器下載該 HTML 中引用的 JavaScript 檔案。
4.  JS 下載並執行完畢後，才開始在瀏覽器中產生頁面內容，並掛載到 DOM 上。

這種作法在首次載入後，頁面切換可以很流暢，但產生了幾個顯著的缺點：

* **SEO 效果不佳**：搜尋引擎爬蟲抓取到的是近乎空白的 HTML，因為許多爬蟲不會等待 JavaScript 執行完畢，導致無法正確索引頁面內容。
* **社群平台連結預覽失敗**：分享連結時，社群平台的爬蟲同樣抓不到內容，無法產生包含標題、描述和圖片的預覽卡片。
* **首次載入效能差**：在任何內容出現前，使用者必須等待整個 JS 檔案包下載並執行完畢，這段「白畫面」時間造成了不好的使用者體驗。

![image](https://hackmd.io/_uploads/SyjF1k6Tel.png)


## 2. 解決方案一：伺服器端渲染 (SSR)

為了解決 CSR 的問題，第一個成熟的方案就是**伺服器端渲染 (Server-Side Rendering, SSR)**。這也是 Next.js 提供的兩種主要預先渲染模式之一。

在 SSR 模式下，伺服器在接收到**每一次的頁面請求**時，都會在後端執行 React 程式碼，產生一份包含完整內容的 HTML 文件後，再回傳給瀏覽器。

因為瀏覽器從一開始就收到了完整的 HTML，所以內容可以立即顯示給使用者，同時也解決了 SEO 和連結預覽的問題。這種讓同一份 React 程式碼既能在伺服器運行、也能在客戶端運行的技術，就是早期被稱為「同構 (Isomorphic)」或「通用 (Universal)」JavaScript 的現代實踐。

![image](https://hackmd.io/_uploads/B1Wik16aex.png)


#### **Hydration：為靜態頁面注入互動性**

SSR 產生的 HTML 雖然內容完整，但它起初是靜態的，缺乏互動性。當瀏覽器在背景下載完畢對應的 JavaScript 檔案後，會執行一個稱為 **Hydration (水合)** 的過程。React 會遍歷伺服器渲染好的 DOM 結構，並為其附加事件監聽器 (例如 `onClick`)，讓頁面「活過來」，變得完全可互動，而不需要在客戶端從頭重新渲染一次。

在 Next.js 中，要為一個頁面啟用 SSR，只需在該頁面檔案中導出一個名為 `getServerSideProps` 的 `async` 函式。

* **適用場景**：需要顯示高度動態、或使用者特定資料的頁面。例如，使用者後台、即時更新的儀表板等，這些頁面需要確保每次造訪時資料都是最新的。

## 3. 解決方案二：靜態網站生成 (SSG)

**靜態網站生成 (Static Site Generation, SSG)** 是另一種預先渲染模式，它將這個概念推向了極致。在 SSG 模式下，所有頁面的 HTML 會在**專案打包時 (build time)** 就一次性全部生成好。

當專案部署後，這些 HTML 檔案就只是單純的靜態資源，可以被放置在全球各地的 CDN (內容分發網路) 上。當使用者請求頁面時，CDN 會直接從離他最近的節點回傳預先生成好的 HTML 檔案，載入速度非常快。

在 Next.js 中，SSG 是透過 `getStaticProps` 函式來實現的。

* **適用場景**：內容不常變動，且對所有使用者都相同的頁面。這是部落格文章、行銷頁面、產品目錄、說明文件等內容型網站的理想選擇。就效能而言，SSG 通常是最好的選項。

## 4. 混合策略：增量靜態再生 (ISR)

如果我們想要 SSG 的高效能，但又希望內容能夠在部署後定期更新，而不需要重新打包整個網站呢？這時就可以使用**增量靜態再生 (Incremental Static Regeneration, ISR)**。

ISR 允許我們在網站運行時，對靜態頁面進行更新。它的運作機制如下：
1.  頁面在打包時會先生成一份靜態版本。
2.  我們可以為頁面設定一個 `revalidate` 的時間（例如：每 60 秒）。
3.  當使用者在 60 秒後發出請求時，他會**立即**收到舊的（快取的）靜態頁面。
4.  **同時**，Next.js 會在背景觸發一次頁面的重新生成。
5.  一旦新頁面生成成功，快取就會被更新。之後的所有訪客都會看到最新的內容。

這個作法的優點是，使用者永遠不會因為頁面再生而需要等待。在 Next.js 中，要啟用 ISR，只需在 `getStaticProps` 回傳的物件中加上 `revalidate` 屬性即可。

![image](https://hackmd.io/_uploads/rkfV2C2aex.png)


## 5. 小結：如何選擇？

Next.js 的優勢在於，我們可以為應用程式中的**每一個頁面**，單獨選擇最適合的渲染策略。

| 策略 | 運作方式 | 適用場景 | Next.js 方法 |
| :--- | :--- | :--- | :--- |
| **CSR** | 在使用者瀏覽器中用 JS 生成 HTML。 | 需要高度互動、且不依賴 SEO 的後台儀表板。 | `useEffect()` 或 `SWR` |
| **SSR** | 伺服器在每次請求時生成 HTML。 | 內容頻繁變動或因人而異的頁面 (如個人帳戶頁)。 | `getServerSideProps()` |
| **SSG** | 在打包時一次性生成所有 HTML。 | 內容不常變動的頁面 (如部落格、行銷頁、文件)。 | `getStaticProps()` |
| **ISR** | 打包時生成，部署後可依計時器重新生成。 | 大部分為靜態，但需定期更新內容的頁面 (如新聞網站)。 | `getStaticProps()` 搭配 `revalidate` |

透過靈活組合這些渲染模式，我們就能根據實際需求，打造出兼具效能、SEO 與良好使用者體驗的現代網頁應用。

![image](https://hackmd.io/_uploads/r1dbDJp6el.png)
