---
title: "SSR 到底是什麼？從 PHP 到 React Server Components 的前端渲染進化史"
date: 2024-01-04
categories:
  - 前端二三事
  - 前端歷史
tags:
  - SSR
  - Isomorphic
  - React
  - Next.js
excerpt: "伺服器端渲染的定義隨著時代不斷演變。本文將帶你回顧從傳統 PHP 渲染，到現代 React Server Components 的前端渲染技術發展歷程。"
series: frontend
series_index: 2
---

**系列導覽：**
* [« 不只 React，更勝 React：為什麼你的下一個專案應該考慮 Next.js？](/nextjs-why-framework)
* [下一篇：Next.js 的渲染策略：SSR、SSG、ISR 與 CSR 的實戰比較 »](/nextjs-rendering-strategies)


當一位開發者跟你提到「Server-Side Rendering」或「SSR」時，他指的到底是什麼？是傳統的 PHP 網站，還是一個用 React 打造的現代 SPA？「SSR」這個詞已經變得有點混亂，因為在不同語境下，它可能代表著完全不同的技術架構。

在現代前端的討論中，稱呼一個 PHP 網站為「SSR」，就像稱呼「湯」為一種「飲料」。雖然字面意義上沒錯——都是可以喝的液體——但卻忽略了語境。大家講「飲料」時，腦中浮現的是解渴、裝在杯子裡的特定情境；同樣地，今天我們講「SSR」，其實是在**指稱一整套為了解決特定問題而生的解決方案**。

這個詞的現代意義，是隨著 SPA (單頁式應用程式) 的興起而確立的。當開發者們開始用 JavaScript 在瀏覽器端建構整個應用程式時，也催生了一系列新的挑戰。「SSR」因此演變為那些「為了解決客戶端渲染 (CSR) 問題」的伺服器技術的總稱。

這篇文章，就是一趟穿越前端渲染歷史的時光之旅。我們將從最早的伺服器渲染時代，走到客戶端渲染的革命，再到那些試圖融合兩者優點的先進技術，最終抵達像 React Server Components 這樣的前沿領域。

## 1. 美好的舊時代與 SPA 的崛起

在 SPA 出現之前，PHP、Ruby、Java 這類後端語言是網頁渲染的唯一主角。流程很單純：伺服器收到請求，產生完整的 HTML，然後送給瀏覽器。因為這是當時唯一的做法，所以根本不需要「SSR」這種特別的稱呼。


這一切的轉捩點，源自一個關鍵的瀏覽器 API：`XMLHttpRequest`。這個技術讓網頁可以在**不刷新整個頁面**的情況下，與伺服器交換資料。2005 年，Jesse James Garrett 將這種結合了 HTML、CSS、DOM 和 `XMLHttpRequest` 的新方法，命名為 **"Ajax"**。

這個新模式催生了第一批前端框架的浪潮，其中最具代表性的就是 Backbone.js (2010) 和 AngularJS (2010)。它們讓開發者能打造出完全運行在客戶端的複雜應用程式。然而，我們用「伺服器延遲」換來了「前端巨大的 JS 檔案包」，這個架構上的取捨，立刻帶來了兩個致命傷：

* **糟糕的 SEO**：搜尋引擎爬蟲抓到的 SPA 頁面，往往只有一個空殼 `<div>` 和一個巨大的 `<script>` 標籤。內容都得靠 JS 生成，導致爬蟲根本看不懂頁面內容。
* **糟糕的首次載入體驗**：使用者常常得盯著一片白畫面，等待巨大的 JS 檔案下載、解析、執行完畢。這種被稱為「白畫面恐懼症」的現象，帶來了極差的效能觀感。 

|  | | 
| -------- | -------- |
| ![image](https://hackmd.io/_uploads/SJykvC36ll.png)| ![image](https://hackmd.io/_uploads/Hyew7v02pxl.png)
 |

## 2. 早期補救：馴服 SPA 的第一次嘗試

當開發者開始與 CSR 的問題搏鬥時，各種解決方案也應運而生。這些早期的技術，可以說是現代意義上 SSR 的第一代。

### 解法一：為爬蟲準備「特供版」網頁 (Cloaking)

最簡單粗暴的方法，就是看人下菜碟。伺服器檢查請求的 `user-agent`，如果發現是搜尋引擎，就回傳一個內容豐富的靜態 HTML；如果是真人使用者，就照常回傳 SPA 的空殼。

* **優點**：快速、簡單，不用改動前端 SPA 的邏輯。
* **缺點**：這種被稱為「**Cloaking (偽裝)**」的作法是 SEO 大忌。搜尋引擎希望它看到的內容和使用者看到的一樣，否則可能會對網站進行懲罰。

### 解法二：用無頭瀏覽器預先渲染 (Pre-rendering)

為了避免 Cloaking 的懲罰，更進階的作法出現了。像 Prerender 這類服務，會在伺服器上用一個沒有圖形介面的「無頭瀏覽器」(Headless Browser) 去打開你的 SPA，等 JS 執行完畢、畫面渲染完成後，再把最終的 HTML 結果存起來。

這個靜態的 HTML 檔案專門用來服務搜尋引擎，因為內容和使用者最終看到的結果一致，所以解決了 SEO 問題。但新的使用者體驗問題又來了：

如果你把這個預渲染好的 HTML 直接給真人使用者，他雖然能立刻看到內容，但頁面會發生一次**詭異的「閃爍」**。這是因為客戶端的 React App 載入後，並不知道頁面上已經有內容了，它會用自己的空狀態重新渲染一次，把畫面清空，然後再去請求資料，再渲染一次。使用者眼睜睜看著畫面從「有內容 -> 變空白 -> 再變回有內容」。
![image](https://hackmd.io/_uploads/S1JWMR2axg.png)


### 解法三：終極聖杯 - 同構 (Isomorphic) JavaScript

前兩種方法都只是補丁，社群真正尋找的是能完美解決所有問題的「聖杯」。這個聖杯，就是 **Isomorphic JavaScript** (後來更常被稱為 **Universal JavaScript**) 的概念。

> **同構 (Isomorphic) 的核心思想：**
> 「同一份 JavaScript 程式碼，既可以在伺服器上運行，也可以在客戶端上運行。」

這個概念的先驅是 Airbnb 在 2013 年為 Backbone.js 發布的 `Rendr` 函式庫。它的渲染流程是這樣的：

1.  使用者發出第一次請求，伺服器執行**和瀏覽器端完全相同**的 JS 應用程式碼。
2.  伺服器擷取資料，產生一份**內容完整**的 HTML 文件。
3.  瀏覽器收到這份 HTML，使用者**立刻**看到有意義的內容。
4.  在此同時，前端的 JS 檔案包在背景下載。下載完畢後，它會「接管」這個靜態頁面，綁定事件監聽器，讓頁面變得可互動。這個過程，我們稱為 **Hydration (水合)**。

## 3. 現代篇章：框架如何將 SSR 標準化

雖然 `Rendr` 證明了「聖杯」是可行的，但也暴露了其背後巨大的複雜性。開發者現在必須同時處理伺服器環境、Hydration 策略、前後端路由、複雜的打包工具等等。

這個巨大的痛點，催生了像 **Next.js** 這樣內建 Universal Rendering 功能的框架。它們將複雜的流程標準化為兩種主流模式：

* **SSR (Server-Side Rendering)**：伺服器在**每一次請求**時都即時產生新的 HTML。適合動態、個人化的內容。在 Next.js 中，通常用 `getServerSideProps` 實現。
* **SSG (Static Site Generation)**：HTML 在**專案打包時**就一次性生成好。使用者請求時，直接回傳一個靜態檔案。適合內容對所有使用者都一樣的頁面，例如部落格文章。在 Next.js 中，用 `getStaticProps` 實現。

## 4. 未來趨勢：SSR 的軍備競賽 - Hydration 優化

渲染技術的演進並未停止。下一個戰場，轉移到了如何讓 **Hydration** 過程本身變得更有效率，核心目標是：**送最少的 JavaScript，讓頁面最快可互動**。

![image](https://hackmd.io/_uploads/Skh7GA36ge.png)


這場軍備競賽催生了幾項關鍵創新：

* **漸進式水合 (Progressive Hydration)**：不再一次性 Hydrate 整個頁面，而是分塊、有優先級地進行。重要的元件（如搜尋框）先互動，次要的（如頁腳）稍後再處理。
* **選擇性水合 (Selective Hydration)**：更進一步，如果一個元件只是純靜態展示，根本沒有互動功能，那為什麼要為它載入 JS 呢？乾脆跳過它的 Hydration 過程。
* **孤島架構 (Islands Architecture)**：由 Astro 等框架推廣。它將網頁視為一片靜態 HTML 的海洋，其中點綴著一座座獨立、可互動的元件「孤島」。靜態 HTML 瞬間載入，而每座孤島可以獨立進行 Hydration。
* **React Server Components (RSC)**：這是 React 官方的終極答案。它讓開發者能明確區分哪些元件**只在伺服器上運行**（產出純靜態 HTML），哪些是需要送到瀏覽器進行 Hydration 的傳統互動元件。這種精細的控制力，能最大程度地減少傳送到客戶端的 JS 體積。

![image](https://hackmd.io/_uploads/HJlHzRhpex.png)


## 結論：一場永不停歇的旅程

前端渲染的歷史，就是一場為了追求極致使用者體驗而展開的演化史。我們從一個完全由伺服器主導的世界 (PHP) 開始，擺盪到另一個由客戶端主導的極端 (SPA)，然後花了近十年的時間，發展出各種越來越成熟的技術，試圖融合兩個世界的優點。

「SSR」這個詞的意義，始終是相對於「CSR」而存在的。它的定義不是靜態的，而是一個不斷演變的標籤，代表著那些旨在彌補我們在客戶端革命中失去的效能與可發現性的架構模式。

今天，這趟旅程仍在繼續。從經典的 SSR 到孤島架構，再到 React Server Components，這條演進之路清晰地告訴我們：業界對於「更快、更高效地交付豐富互動體驗」的追求，永無止境。



---

### 系列文章導覽

* **前一篇**：[不只 React，更勝 React：為什麼你的下一個專案應該考慮 Next.js？](/nextjs-why-framework)
* **目前位置**：[{{ page.title }}]({{ page.url }})
* **下一篇**：[Next.js 的渲染策略：SSR、SSG、ISR 與 CSR 的實戰比較](/nextjs-rendering-strategies)